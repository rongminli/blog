<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chromium的多进程架构 | LRM的笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/blog/assets/css/0.styles.5ce66c8b.css" as="style"><link rel="preload" href="/blog/assets/js/app.9f0d3d57.js" as="script"><link rel="preload" href="/blog/assets/js/2.31e7eaac.js" as="script"><link rel="preload" href="/blog/assets/js/6.15c032ef.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.e0c34b25.js"><link rel="prefetch" href="/blog/assets/js/11.9733fdbe.js"><link rel="prefetch" href="/blog/assets/js/12.f38b06d4.js"><link rel="prefetch" href="/blog/assets/js/13.4623a3ca.js"><link rel="prefetch" href="/blog/assets/js/14.8667e4ef.js"><link rel="prefetch" href="/blog/assets/js/15.3351213e.js"><link rel="prefetch" href="/blog/assets/js/16.5e408412.js"><link rel="prefetch" href="/blog/assets/js/17.21e2ea52.js"><link rel="prefetch" href="/blog/assets/js/18.9e4522ec.js"><link rel="prefetch" href="/blog/assets/js/19.90702316.js"><link rel="prefetch" href="/blog/assets/js/20.fec304cd.js"><link rel="prefetch" href="/blog/assets/js/21.ae45e28a.js"><link rel="prefetch" href="/blog/assets/js/22.82fabc13.js"><link rel="prefetch" href="/blog/assets/js/23.83200369.js"><link rel="prefetch" href="/blog/assets/js/24.4c33f372.js"><link rel="prefetch" href="/blog/assets/js/3.71d7076e.js"><link rel="prefetch" href="/blog/assets/js/4.81286938.js"><link rel="prefetch" href="/blog/assets/js/5.5cbb8dc4.js"><link rel="prefetch" href="/blog/assets/js/7.72825ffb.js"><link rel="prefetch" href="/blog/assets/js/8.eac49056.js"><link rel="prefetch" href="/blog/assets/js/9.1107ed4b.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5ce66c8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">LRM的笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/blog/browser/page_load.html" class="sidebar-link">浏览器加载过程</a></li><li><a href="/blog/browser/multi_process.html" aria-current="page" class="active sidebar-link">浏览器架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#问题" class="sidebar-link">问题</a></li><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#架构概览" class="sidebar-link">架构概览</a></li><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#管理渲染进程" class="sidebar-link">管理渲染进程</a></li><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#管理frame和文档" class="sidebar-link">管理frame和文档</a></li><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#组件和接口" class="sidebar-link">组件和接口</a></li><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#共享渲染器进程" class="sidebar-link">共享渲染器进程</a></li><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#发现已崩溃或者行为不当的渲染器" class="sidebar-link">发现已崩溃或者行为不当的渲染器</a></li><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#渲染器沙盒化" class="sidebar-link">渲染器沙盒化</a></li><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#内存回收" class="sidebar-link">内存回收</a></li><li class="sidebar-sub-header"><a href="/blog/browser/multi_process.html#其他进程类型" class="sidebar-link">其他进程类型</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="chromium的多进程架构"><a href="#chromium的多进程架构" class="header-anchor">#</a> Chromium的多进程架构</h1> <p>本篇讲解chromium的高级架构，以及其如何区分不同的进程类型。</p> <h2 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h2> <p>构建绝不会宕机和绝对安全的渲染引擎事几乎不可能的。</p> <p>从某方面说，2006年前后的浏览器像是过去单用户，多进程任务协作的操作系统。一个行为不端的应用会使这样的操作系统崩溃，同样一个不正常的网页也会使这样的浏览器崩溃。只要一个渲染引擎或者插件出bug就会干掉整个浏览器和正在运行的标签页。</p> <p>现代操作系统则更加健壮，因为它们把不同的应用放在彼此隔离的进程中。一个应用崩溃不会损害刀其他的应用或者操作系统的完整性，而且每个用户能访问到的其他用户的数据是有限的。Chromium的架构旨在实现这种更加健壮的设计模式。</p> <h2 id="架构概览"><a href="#架构概览" class="header-anchor">#</a> 架构概览</h2> <p>Chromium 使用多进程保护所有的应用免受渲染引擎或其它组件中的bug和小故障的影响。它还限制了每个渲染引擎进程对其他进程和系统其他部分的访问。某种程度上，这给浏览器的内存保护和限制自身对操作系统的访问带来了便利。</p> <p>我们把运行UI和管理渲染器以及其它进程的之进程称为“浏览器进程”或者“浏览器”（“browser process” or “browser”），同样的，处理网页内容的进程称为“渲染进程”或者“渲染器”。渲染器使用开源的布局引擎Blink来解析和布局HTML。</p> <p><img src="/blog/assets/img/browser_achi.8858a12c.png" alt="浏览器进程架构图"></p> <h2 id="管理渲染进程"><a href="#管理渲染进程" class="header-anchor">#</a> 管理渲染进程</h2> <p>每一个渲染进程有一个全局<code>RenderProcess</code>对象，用来管理与父浏览器进程的通讯以及维护全局状态。浏览器维护与每一个渲染进程相对应的<code>RenderProcessHost</code>对象，用来管理浏览器状态并和对应的渲染器通讯。浏览和渲染器之间的通讯使用Mojo或者Chromium的IPC系统。</p> <h2 id="管理frame和文档"><a href="#管理frame和文档" class="header-anchor">#</a> 管理frame和文档</h2> <p>每一个渲染进程有一个或者多个<code>RenderFrame</code>对象对应到包含内容文档的frame。相应的<code>RenderFrameHost</code>在浏览器进程中管理与文档对应的状态。每个<code>RenderFrame</code>都有一个路由ID，用于区分同一个渲染器中的多个文档或frame。这些ID在每一个渲染进程中都是唯一的，但是在多个渲染器之间不唯一，所以定位一个frame需要一个<code>RenderProcessHost</code>和一个路由ID。在渲染器中的特定文档与浏览器之间的通讯通过<code>RenderProcessHost</code>完成，它知道如何通过Mojo或IPC来发送消息。</p> <h2 id="组件和接口"><a href="#组件和接口" class="header-anchor">#</a> 组件和接口</h2> <p>在渲染器进程中：</p> <ul><li><code>RenderProcess</code>在浏览器中和相应的<code>RenderProcessHost</code>处理Mojo设置和遗留IPC。每个渲染器进程只有一个<code>RenderProcess</code>对象。</li> <li><code>RenderFrame</code>对象在浏览器进程(通过Mojo)和Blink层中与相应的<code>RenderFrameHost</code>通信。该对象表示一个web文档在一个标签或子frame中的内容。</li></ul> <p>在浏览器进程中：</p> <ul><li><code>Browser</code>对象表示顶级的浏览器窗口。</li> <li><code>RenderProcessHost</code>对象表示浏览器端的一个单一的浏览器到渲染器的IPC链接。每个渲染器进程在浏览器进程中有一个<code>RenderProcessHost</code>.</li> <li><code>RenderFrameHost</code>对象封装了与<code>RenderFrame</code>的通信，<code>RenderWidgetHost</code>处理浏览器中<code>RenderWidget</code>的输入和绘制。</li></ul> <p>更多细节参阅<a href="/blog/browser/page_render.html">网页是如何显示的</a></p> <h2 id="共享渲染器进程"><a href="#共享渲染器进程" class="header-anchor">#</a> 共享渲染器进程</h2> <p>通常，每个新的窗口和标签在一个新的进程中开启。浏览器开启新的进程指导它创建一个<code>RenderFrame</code>，这个<code>RenderFrame</code>可能在页面中创建更多的<code>iframe</code>（它们可能在不同的进程中）。</p> <p>有时在不同窗口中共享渲染进程是必须的。例如，一个网络应用可以使用<code>window.open</code>创建别的窗口，如果新的文档来自同一个源，那么新的文档需要和父窗口公用一个渲染进程。如果进程总数太大，Chromium还具有将新标签页分配给现有进程的策略。这些注意事项和策略在<a href="">进程模型</a>中进行了描述。</p> <h2 id="发现已崩溃或者行为不当的渲染器"><a href="#发现已崩溃或者行为不当的渲染器" class="header-anchor">#</a> 发现已崩溃或者行为不当的渲染器</h2> <p>到浏览器进程的每个Mojo或IPC连接都监视进程句柄。如果这些句柄已发出信号，则表示渲染程序已经崩溃，受影响的标签和frame将被通知崩溃。Chromium显示一个“悲伤标签”或“悲伤帧”图像，通知用户渲染器已经崩溃。可以通过按下重新加载按钮或开始一个新的导航来重新加载页面。当这种情况发生时，Chromium会注意到没有渲染器进程，并创建一个新的渲染器进程。</p> <h2 id="渲染器沙盒化"><a href="#渲染器沙盒化" class="header-anchor">#</a> 渲染器沙盒化</h2> <p>鉴于渲染器运行在一个单独的进程中，我们有机会通过沙箱限制它对系统资源的访问。例如，我们可以确保渲染器对网络的唯一访问是通过Chromium的网络服务。同样，我们可以使用主机操作系统的内置权限限制其对文件系统的访问，或者限制其对用户显示和输入的访问。这些限制极大地限制了折衷的呈现程序进程能够完成的任务。</p> <h2 id="内存回收"><a href="#内存回收" class="header-anchor">#</a> 内存回收</h2> <p>由于渲染器运行在独立的进程中，通过降低优先级来隐藏标签变得很简单。通常，Windows上最小化的进程的内存会自动放入“可用内存”池中。在内存不足的情况下，Windows会在交换高优先级内存之前将这些内存交换到磁盘，这有助于保持用户可见程序的响应更快。我们可以将同样的原则应用于隐藏选项卡。当呈现进程没有顶级选项卡时，我们可以释放该进程的“工作集”大小，以提示系统在必要时首先将内存交换到磁盘。因为我们发现，当用户在两个选项卡之间切换时，减少工作集大小也会降低选项卡切换性能，所以我们逐渐释放这些内存。这意味着如果用户切换回最近使用的选项卡，该选项卡的内存比最近使用较少的选项卡更有可能被换回。有足够内存运行所有程序的用户不会注意到这一点。</p> <p>这有助于我们在内存不足的情况下获得更优的内存占用。与很少使用的后台选项卡相关的内存可以完全交换，而前台选项卡的数据可以完全加载到内存中。相比之下，单进程浏览器将所有选项卡的数据随机分布在内存中，不可能将使用和未使用的数据如此干净地分开，这会浪费内存和性能。</p> <h2 id="其他进程类型"><a href="#其他进程类型" class="header-anchor">#</a> 其他进程类型</h2> <p>Chromium也将许多其他组件分离到单独的过程中，有时以特定于平台的方式进行。例如，它现在有一个单独的GPU进程、网络服务和存储服务。沙盒实用程序进程还可以用于小型或有风险的任务，作为满足安全性的二规则的一种方式。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/browser/page_load.html" class="prev">
        浏览器加载过程
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.9f0d3d57.js" defer></script><script src="/blog/assets/js/2.31e7eaac.js" defer></script><script src="/blog/assets/js/6.15c032ef.js" defer></script>
  </body>
</html>
