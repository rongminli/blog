<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>匹配控制流结构是什么 | LRM的笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/blog/assets/css/0.styles.5ce66c8b.css" as="style"><link rel="preload" href="/blog/assets/js/app.9f0d3d57.js" as="script"><link rel="preload" href="/blog/assets/js/2.31e7eaac.js" as="script"><link rel="preload" href="/blog/assets/js/18.9e4522ec.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.e0c34b25.js"><link rel="prefetch" href="/blog/assets/js/11.9733fdbe.js"><link rel="prefetch" href="/blog/assets/js/12.f38b06d4.js"><link rel="prefetch" href="/blog/assets/js/13.4623a3ca.js"><link rel="prefetch" href="/blog/assets/js/14.8667e4ef.js"><link rel="prefetch" href="/blog/assets/js/15.3351213e.js"><link rel="prefetch" href="/blog/assets/js/16.5e408412.js"><link rel="prefetch" href="/blog/assets/js/17.21e2ea52.js"><link rel="prefetch" href="/blog/assets/js/19.90702316.js"><link rel="prefetch" href="/blog/assets/js/20.fec304cd.js"><link rel="prefetch" href="/blog/assets/js/21.ae45e28a.js"><link rel="prefetch" href="/blog/assets/js/22.82fabc13.js"><link rel="prefetch" href="/blog/assets/js/23.83200369.js"><link rel="prefetch" href="/blog/assets/js/24.4c33f372.js"><link rel="prefetch" href="/blog/assets/js/3.71d7076e.js"><link rel="prefetch" href="/blog/assets/js/4.81286938.js"><link rel="prefetch" href="/blog/assets/js/5.5cbb8dc4.js"><link rel="prefetch" href="/blog/assets/js/6.15c032ef.js"><link rel="prefetch" href="/blog/assets/js/7.72825ffb.js"><link rel="prefetch" href="/blog/assets/js/8.eac49056.js"><link rel="prefetch" href="/blog/assets/js/9.1107ed4b.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5ce66c8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">LRM的笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/blog/rust/6_enums_and_pattern_matching/index" class="sidebar-heading clickable open"><span>第六章 枚举和模式匹配</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/rust/6_enums_and_pattern_matching/6.1_define_an_enum.html" class="sidebar-link">6.1 枚举的创建和Option&lt;T&gt;</a></li><li><a href="/blog/rust/6_enums_and_pattern_matching/6.2_The_match_control_flow_construct.html" aria-current="page" class="active sidebar-link">6.2 匹配控制流结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/rust/6_enums_and_pattern_matching/6.2_The_match_control_flow_construct.html#匹配控制流结构是什么" class="sidebar-link">匹配控制流结构是什么</a></li><li class="sidebar-sub-header"><a href="/blog/rust/6_enums_and_pattern_matching/6.2_The_match_control_flow_construct.html#绑定到值的模式" class="sidebar-link">绑定到值的模式</a></li><li class="sidebar-sub-header"><a href="/blog/rust/6_enums_and_pattern_matching/6.2_The_match_control_flow_construct.html#使用option-t-进行匹配" class="sidebar-link">使用Option&lt;T&gt;进行匹配</a></li><li class="sidebar-sub-header"><a href="/blog/rust/6_enums_and_pattern_matching/6.2_The_match_control_flow_construct.html#匹配的穷竭性" class="sidebar-link">匹配的穷竭性</a></li><li class="sidebar-sub-header"><a href="/blog/rust/6_enums_and_pattern_matching/6.2_The_match_control_flow_construct.html#catch-all模式和-占位符" class="sidebar-link">Catch-all模式和_占位符</a></li></ul></li><li><a href="/blog/rust/6_enums_and_pattern_matching/6.3_concise_control_flow_with_if_let.html" class="sidebar-link">6.3 简明控制流if let</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/rust/8_common_collections/index" class="sidebar-heading clickable"><span>第六章 常用集合</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="匹配控制流结构是什么"><a href="#匹配控制流结构是什么" class="header-anchor">#</a> 匹配控制流结构是什么</h2> <p>Rust有一个非常强大的控制流结构，称为match，它允许您将值与一系列模式进行比较，然后根据匹配的模式执行代码。模式可以由文字值、变量名、通配符和许多其他东西组成;第18章涵盖了所有不同类型的模式及其作用。匹配的力量来自于模式的表达性，以及编译器确认所有可能的情况都得到了处理。</p> <p>把匹配表达式想象成一个硬币分拣机:硬币沿着带有不同大小孔的轨道滑下，每枚硬币从它遇到的第一个适合它的孔中掉下来。以同样的方式，值在匹配中的每个模式中进行遍历，在值“适合”的第一个模式中，值落入执行期间使用的关联代码块中。</p> <p>说到硬币，让我们以它们为例来使用match!我们可以编写一个函数，它接受一枚未知的美国硬币，以与计数机类似的方式确定这是哪枚硬币，并以美分为单位返回它的值，如清单6-3所示。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">enum</span> <span class="token type-definition class-name">Coin</span> <span class="token punctuation">{</span>
    <span class="token class-name">Penny</span><span class="token punctuation">,</span>
    <span class="token class-name">Nickel</span><span class="token punctuation">,</span>
    <span class="token class-name">Dime</span><span class="token punctuation">,</span>
    <span class="token class-name">Quarter</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">value_in_cents</span><span class="token punctuation">(</span>coin<span class="token punctuation">:</span> <span class="token class-name">Coin</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u8</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> coin <span class="token punctuation">{</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Penny</span> <span class="token operator">=&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Nickel</span> <span class="token operator">=&gt;</span> <span class="token number">5</span><span class="token punctuation">,</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Dime</span> <span class="token operator">=&gt;</span> <span class="token number">10</span><span class="token punctuation">,</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Quarter</span> <span class="token operator">=&gt;</span> <span class="token number">25</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>清单6-3:一个枚举和一个匹配表达式，它使用枚举的变体作为其模式</p> <p>让我们在value_in_cents函数中分解匹配。首先，我们列出match关键字，后面跟着一个表达式，在本例中是value coin。这看起来非常类似与if一起使用的表达式，但有一个很大的区别:如果使用if，表达式需要返回一个布尔值，但在这里，它可以返回任何类型。本例中的coin类型是我们在第一行上定义的coin enum。</p> <p>接下来是 <code>match</code> 的分支。一个分支有两个部分:一个模式和一些代码。这里的第一个分支有一个模式，即值Coin::Penny，然后是=&gt;操作符，它将模式和要运行的代码分开。本例中的代码只是值1。每条分支都用逗号隔开。</p> <p>当匹配表达式执行时，它会按顺序将结果值与每个分支的模式进行比较。如果模式与值匹配，则执行与该模式关联的代码。如果该模式与值不匹配，将继续执行到下一个分支，就像硬币分拣机一样。我们可以有我们需要的任意多的分支:在清单6-3中，我们的有四个分支。</p> <p>与每个分支相关联的代码是一个表达式，匹配分支中表达式的结果值是整个匹配表达式的返回值。</p> <p>如果匹配分支代码很短，我们通常不使用花括号，如清单6-3所示，其中每个分支只返回一个值。如果希望在匹配臂中运行多行代码，则必须使用花括号，然后分支后的逗号是可选的。例如，下面的代码打印“Lucky penny!”每次用Coin::Penny调用该方法时，仍然返回块的最后一个值1:</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">value_in_cents</span><span class="token punctuation">(</span>coin<span class="token punctuation">:</span> <span class="token class-name">Coin</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u8</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> coin <span class="token punctuation">{</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Penny</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Lucky penny!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token number">1</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Nickel</span> <span class="token operator">=&gt;</span> <span class="token number">5</span><span class="token punctuation">,</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Dime</span> <span class="token operator">=&gt;</span> <span class="token number">10</span><span class="token punctuation">,</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Quarter</span> <span class="token operator">=&gt;</span> <span class="token number">25</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="绑定到值的模式"><a href="#绑定到值的模式" class="header-anchor">#</a> 绑定到值的模式</h2> <p>匹配臂的另一个有用的特性是，它们可以绑定到与模式匹配的值的部分。这就是我们如何从枚举变量中提取值的方法。</p> <p>作为示例，让我们更改一个枚举变量，以在其中保存数据。从1999年到2008年，美国为50个州的每一面铸造了不同的设计。没有其他硬币有国家图案，所以只有25美分的硬币有这种额外的值。我们可以通过更改Quarter变量来将存储在其中的UsState值添加到枚举中，如清单6-4所示。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span> <span class="token comment">// so we can inspect the state in a minute</span>
<span class="token keyword">enum</span> <span class="token type-definition class-name">UsState</span> <span class="token punctuation">{</span>
    <span class="token class-name">Alabama</span><span class="token punctuation">,</span>
    <span class="token class-name">Alaska</span><span class="token punctuation">,</span>
    <span class="token comment">// --snip--</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token type-definition class-name">Coin</span> <span class="token punctuation">{</span>
    <span class="token class-name">Penny</span><span class="token punctuation">,</span>
    <span class="token class-name">Nickel</span><span class="token punctuation">,</span>
    <span class="token class-name">Dime</span><span class="token punctuation">,</span>
    <span class="token class-name">Quarter</span><span class="token punctuation">(</span><span class="token class-name">UsState</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>清单6-4:一个Coin enum，其中Quarter变量也包含一个UsState值</p> <p>让我们想象一下，一个朋友正试图收集所有50个州的25美分硬币。虽然我们会根据硬币类型对零钱进行分类，但我们也会列出与每个硬币相关的州名，所以如果我们的朋友没有硬币，他们便可以将其添加到自己的收藏中。</p> <p>在这段代码的匹配表达式中，我们将一个名为state的变量添加到匹配变体Coin::Quarter的值的模式中。当Coin::Quarter匹配时，状态变量将绑定到该Quarter的状态值。然后我们可以在这个手臂的代码中使用state，像这样:</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">value_in_cents</span><span class="token punctuation">(</span>coin<span class="token punctuation">:</span> <span class="token class-name">Coin</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u8</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> coin <span class="token punctuation">{</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Penny</span> <span class="token operator">=&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Nickel</span> <span class="token operator">=&gt;</span> <span class="token number">5</span><span class="token punctuation">,</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Dime</span> <span class="token operator">=&gt;</span> <span class="token number">10</span><span class="token punctuation">,</span>
        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Quarter</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;State quarter from {:?}!&quot;</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token number">25</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果我们调用value_in_cents(Coin::Quarter(UsState::Alaska))， Coin将是Coin::Quarter(UsState::Alaska)。当我们将该值与每个匹配臂进行比较时，它们都不匹配，直到达到Coin::Quarter(状态)。此时，state的绑定值为UsState::Alaska。然后，我们可以在println!表达式，从而从Quarter的Coin enum变量中获得内部状态值。</p> <h2 id="使用option-t-进行匹配"><a href="#使用option-t-进行匹配" class="header-anchor">#</a> 使用<code>Option&lt;T&gt;</code>进行匹配</h2> <p>在上一节中，我们使用<code>Option&lt;T&gt;</code>;我们也可以使用match来处理<code>Option&lt;T&gt;</code>，就像我们处理Coin enum一样!我们不比较硬币，而是比较<code>Option&lt;T&gt;</code>的变体，但匹配表达式的工作方式保持不变。</p> <p>假设我们想写一个函数，它接受<code>Option&lt;i32&gt;</code>，如果里面有一个值，就给这个值加上1。如果内部没有值，函数应该返回None值，并且不尝试执行任何操作。</p> <p>多亏了match，这个函数非常容易编写，如清单6-5所示。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">plus_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> x <span class="token punctuation">{</span>
        <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token class-name">None</span><span class="token punctuation">,</span>
        <span class="token class-name">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> five <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> six <span class="token operator">=</span> <span class="token function">plus_one</span><span class="token punctuation">(</span>five<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> none <span class="token operator">=</span> <span class="token function">plus_one</span><span class="token punctuation">(</span><span class="token class-name">None</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>清单6-5:在<code>Option&lt;i32&gt;</code>上使用匹配表达式的函数</p> <p>让我们更详细地研究一下plus_one的第一次执行。当调用plus_one(5)时，plus_one函数体中的变量x将具有Some(5)的值。然后我们将其与每个匹配的手臂进行比较。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token class-name">None</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Some(5)值与模式None不匹配，因此我们继续进行下一个分支。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code> <span class="token class-name">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Some(5)匹配Some(i)吗?为什么会这样呢?我们有相同的变体。i绑定到Some中包含的值，因此i取值5。然后执行匹配臂中的代码，因此我们将i的值加1，并创建一个包含总数为6的新Some值</p> <p>现在让我们考虑一下清单6-5中plus_one的第二个调用，其中x为None。我们进入比赛，并与第一个手臂进行比较。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token class-name">None</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>它匹配!没有要添加的值，因此程序停止并返回<code>=&gt;</code>右侧的None值。因为第一个臂匹配，所以没有其他臂进行比较。</p> <p>将match和枚举组合在许多情况下都很有用。您将在Rust代码中经常看到这种模式:匹配枚举，将变量绑定到其中的数据，然后基于它执行代码。刚开始这有点棘手，但一旦你习惯了，你就会希望所有语言都能使用它。它一直是用户的最爱。</p> <h2 id="匹配的穷竭性"><a href="#匹配的穷竭性" class="header-anchor">#</a> 匹配的穷竭性</h2> <p>我们还需要讨论匹配的另一个方面:手臂的模式必须涵盖所有可能性。考虑一下这个版本的plus_one函数，它有一个bug，无法编译:</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">plus_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> x <span class="token punctuation">{</span>
        <span class="token class-name">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们没有处理None情况，因此这段代码将导致一个错误。幸运的是，拉斯特知道如何捕捉这种虫子。如果我们试图编译这段代码，我们会得到这样的错误:</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>$ cargo run
   <span class="token class-name">Compiling</span> enums v0<span class="token number">.1</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span>file<span class="token punctuation">:</span><span class="token operator">/</span><span class="token comment">//projects/enums)</span>
error<span class="token punctuation">[</span><span class="token constant">E0004</span><span class="token punctuation">]</span><span class="token punctuation">:</span> non<span class="token operator">-</span>exhaustive patterns<span class="token punctuation">:</span> `<span class="token class-name">None</span>` not covered
   <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">15</span>
    <span class="token operator">|</span>
<span class="token number">3</span>   <span class="token operator">|</span>         <span class="token keyword">match</span> x <span class="token punctuation">{</span>
    <span class="token operator">|</span>               <span class="token operator">^</span> pattern `<span class="token class-name">None</span>` not covered
    <span class="token operator">|</span>
note<span class="token punctuation">:</span> `<span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span>` defined here
    <span class="token operator">=</span> note<span class="token punctuation">:</span> the matched value is of <span class="token keyword">type</span> `<span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span>`
help<span class="token punctuation">:</span> ensure that all possible cases are being handled by adding a <span class="token keyword">match</span> arm with a wildcard pattern or an explicit pattern <span class="token keyword">as</span> shown
    <span class="token operator">|</span>
<span class="token number">4</span>   ~             <span class="token class-name">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token number">5</span>   ~             <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token macro property">todo!</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">|</span>

<span class="token class-name">For</span> more information about this error<span class="token punctuation">,</span> <span class="token keyword">try</span> `rustc <span class="token operator">-</span><span class="token operator">-</span>explain <span class="token constant">E0004</span>`<span class="token punctuation">.</span>
error<span class="token punctuation">:</span> could not compile `enums` due to previous error
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>拉斯特知道我们没有涵盖所有可能的情况甚至知道我们忘记了哪个模式!Rust中的匹配是穷尽的:为了使代码有效，我们必须穷尽每一种可能性。特别是在<code>Option&lt;T&gt;</code>的情况下，当Rust防止我们忘记显式处理None情况时，它保护我们不假设我们有一个可能为null的值，从而使前面讨论的十亿美元的错误不可能发生。</p> <h2 id="catch-all模式和-占位符"><a href="#catch-all模式和-占位符" class="header-anchor">#</a> Catch-all模式和_占位符</h2> <p>使用枚举，我们还可以对一些特定值采取特殊操作，但对所有其他值采取一个默认操作。想象一下，我们正在执行一款游戏，如果你在掷骰子时掷出3，你的玩家不会移动，而是会得到一顶漂亮的新帽子。如果你掷出7，你的玩家将失去一顶漂亮的帽子。对于所有其他数值，你的玩家将在游戏面板上移动相同数量的空间。下面是一个实现该逻辑的匹配，骰子滚动的结果是硬编码的，而不是一个随机值，所有其他逻辑都是用没有主体的函数表示的，因为实际实现它们超出了本例的范围:</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> dice_roll <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">match</span> dice_roll <span class="token punctuation">{</span>
    <span class="token number">3</span> <span class="token operator">=&gt;</span> <span class="token function">add_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token number">7</span> <span class="token operator">=&gt;</span> <span class="token function">remove_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    other <span class="token operator">=&gt;</span> <span class="token function">move_player</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">add_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">remove_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">move_player</span><span class="token punctuation">(</span>num_spaces<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>对于前两个臂，模式是文字值3和7。对于覆盖所有其他可能值的最后一个臂，模式是我们选择命名为other的变量。为另一个手臂运行的代码通过将该变量传递给move_player函数来使用它。</p> <p>尽管我们没有列出u8可能具有的所有值，但这段代码仍然可以编译，因为最后一个模式将匹配没有特别列出的所有值。这种万能模式满足了匹配必须是详尽无遗的要求。注意，我们必须把“全抓”放在最后，因为模式是按顺序计算的。如果我们把全采臂放得更早，其他臂就永远跑不动了，所以如果我们在全采臂之后加臂，Rust就会警告我们!</p> <p>Rust还有一个模式，当我们想要一个全面的模式，但不想使用全面模式中的值时，我们可以使用:_是一个特殊的模式，它匹配任何值，但不绑定到该值。这告诉Rust我们不打算使用该值，因此Rust不会警告我们有未使用的变量。</p> <p>让我们改变游戏规则:现在，如果你摇出的点数不是3或7，你必须再摇一次。我们不再需要使用catch-all值，所以我们可以将代码改为使用_而不是名为other的变量:</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> dice_roll <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">match</span> dice_roll <span class="token punctuation">{</span>
    <span class="token number">3</span> <span class="token operator">=&gt;</span> <span class="token function">add_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token number">7</span> <span class="token operator">=&gt;</span> <span class="token function">remove_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    _ <span class="token operator">=&gt;</span> <span class="token function">reroll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">add_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">remove_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">reroll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个例子也满足了穷竭性的要求，因为我们显式地忽略了最后一个分支中的所有其他值;我们没有忘记任何东西。</p> <p>最后，我们将再一次改变游戏规则，所以如果你摇出3或7以外的点数，那么在你的回合中不会发生其他事情。我们可以通过使用单位值(我们在“元组类型”一节中提到的空元组类型)作为_ arm的代码来表示:</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> dice_roll <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">match</span> dice_roll <span class="token punctuation">{</span>
    <span class="token number">3</span> <span class="token operator">=&gt;</span> <span class="token function">add_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token number">7</span> <span class="token operator">=&gt;</span> <span class="token function">remove_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    _ <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">add_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">remove_fancy_hat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在这里，我们显式地告诉Rust，我们将不会使用任何与早期手臂中的模式不匹配的其他值，在这种情况下，我们不希望运行任何代码。</p> <p>我们将在第18章中介绍更多关于模式和匹配的内容。现在，我们将转到if let语法，它的匹配表达式有点冗长的情况下非常有用。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/rust/6_enums_and_pattern_matching/6.1_define_an_enum.html" class="prev">
        6.1 枚举的创建和Option&lt;T&gt;
      </a></span> <span class="next"><a href="/blog/rust/6_enums_and_pattern_matching/6.3_concise_control_flow_with_if_let.html">
        6.3 简明控制流if let
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.9f0d3d57.js" defer></script><script src="/blog/assets/js/2.31e7eaac.js" defer></script><script src="/blog/assets/js/18.9e4522ec.js" defer></script>
  </body>
</html>
