<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>8.1 使用Vector来存储列表 | LRM的笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/blog/assets/css/0.styles.5ce66c8b.css" as="style"><link rel="preload" href="/blog/assets/js/app.9f0d3d57.js" as="script"><link rel="preload" href="/blog/assets/js/2.31e7eaac.js" as="script"><link rel="preload" href="/blog/assets/js/21.ae45e28a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.e0c34b25.js"><link rel="prefetch" href="/blog/assets/js/11.9733fdbe.js"><link rel="prefetch" href="/blog/assets/js/12.f38b06d4.js"><link rel="prefetch" href="/blog/assets/js/13.4623a3ca.js"><link rel="prefetch" href="/blog/assets/js/14.8667e4ef.js"><link rel="prefetch" href="/blog/assets/js/15.3351213e.js"><link rel="prefetch" href="/blog/assets/js/16.5e408412.js"><link rel="prefetch" href="/blog/assets/js/17.21e2ea52.js"><link rel="prefetch" href="/blog/assets/js/18.9e4522ec.js"><link rel="prefetch" href="/blog/assets/js/19.90702316.js"><link rel="prefetch" href="/blog/assets/js/20.fec304cd.js"><link rel="prefetch" href="/blog/assets/js/22.82fabc13.js"><link rel="prefetch" href="/blog/assets/js/23.83200369.js"><link rel="prefetch" href="/blog/assets/js/24.4c33f372.js"><link rel="prefetch" href="/blog/assets/js/3.71d7076e.js"><link rel="prefetch" href="/blog/assets/js/4.81286938.js"><link rel="prefetch" href="/blog/assets/js/5.5cbb8dc4.js"><link rel="prefetch" href="/blog/assets/js/6.15c032ef.js"><link rel="prefetch" href="/blog/assets/js/7.72825ffb.js"><link rel="prefetch" href="/blog/assets/js/8.eac49056.js"><link rel="prefetch" href="/blog/assets/js/9.1107ed4b.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5ce66c8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">LRM的笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/blog/rust/6_enums_and_pattern_matching/index" class="sidebar-heading clickable"><span>第六章 枚举和模式匹配</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/rust/8_common_collections/index" class="sidebar-heading clickable open"><span>第六章 常用集合</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/rust/8_common_collections/8.1_stores_list_with_vector.html" aria-current="page" class="active sidebar-link">8.1 使用Vector来存储列表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/rust/8_common_collections/8.1_stores_list_with_vector.html#_8-1-1-创建vector" class="sidebar-link">8.1.1 创建Vector</a></li><li class="sidebar-sub-header"><a href="/blog/rust/8_common_collections/8.1_stores_list_with_vector.html#_8-1-2-更新vector" class="sidebar-link">8.1.2 更新Vector</a></li><li class="sidebar-sub-header"><a href="/blog/rust/8_common_collections/8.1_stores_list_with_vector.html#_8-1-3-删除一个vector会同时删除其储存的元素" class="sidebar-link">8.1.3 删除一个Vector会同时删除其储存的元素</a></li><li class="sidebar-sub-header"><a href="/blog/rust/8_common_collections/8.1_stores_list_with_vector.html#_8-1-4-从vector读取值" class="sidebar-link">8.1.4 从Vector读取值</a></li><li class="sidebar-sub-header"><a href="/blog/rust/8_common_collections/8.1_stores_list_with_vector.html#_8-1-5-迭代vector中的值" class="sidebar-link">8.1.5 迭代Vector中的值</a></li><li class="sidebar-sub-header"><a href="/blog/rust/8_common_collections/8.1_stores_list_with_vector.html#_8-1-6-利用枚举存储多个类型的值" class="sidebar-link">8.1.6 利用枚举存储多个类型的值</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_8-1-使用vector来存储列表"><a href="#_8-1-使用vector来存储列表" class="header-anchor">#</a> 8.1 使用Vector来存储列表</h1> <p>第一个我们要讨论的集合类型是 <code>Vec&lt;T&gt;</code>，我们叫它vector。Vector可以在内存中以相邻的方式存储多个值，所有的值必须是同一种数据类型。</p> <h2 id="_8-1-1-创建vector"><a href="#_8-1-1-创建vector" class="header-anchor">#</a> 8.1.1 创建Vector</h2> <p>使用 <code>Vec::new</code> 方法可以创建一个Vector，如下所示。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意，我们在这里添加了一个类型注解。因为没出往Vector中插入任何值，rust无法知晓我们想存储的元素的类型。Vector的实现中使用了泛型，我们将在第十章进一步讨论泛型。现在，我们知道标准库中提供的 <code>Vec&lt;t&gt;</code> 可以存储任何类型，你可以在尖括号中指定你想要存储的类型，在上面的代码中我们告诉rust我们想要存储的类型是i32。
通常，我们使用一些值来初始化<code>Vec&lt;T&gt;</code>，Rust根据这些值的类型来推断你想存储何种类型的元素，因此你通常不需要使用类型注解。Rust提供了一个宏--vec!来根据给定的值来创建新的Vector。以下代码创建了一个持有1，2和3的<code>Vec&lt;i32&gt;</code>，因为整形的默认类型是<code>i32</code>，正如我们在第三章中讨论的那样。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>因为我们使用<code>i32</code>类型的值作为初始化的值，于是Rust推断v的类型是<code>Vec&lt;i32&gt;</code>，所以我们不再需要类型注解。下一步，我们看看如何更改一个vector。</p> <h2 id="_8-1-2-更新vector"><a href="#_8-1-2-更新vector" class="header-anchor">#</a> 8.1.2 更新Vector</h2> <p>我们可以使用<code>push</code>方法往vector添加新的值，如下所示。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>同其他变量一样，如果我们想要改变它的值，我们需要使用<code>mut</code>关键字使它变成可变对象，正如第三章中讨论的那样。我们插入的值都是<code>i32</code>类型，Rust可以中做出推断，因此我们不需要<code>Vec&lt;i32&gt;</code>注解。</p> <h2 id="_8-1-3-删除一个vector会同时删除其储存的元素"><a href="#_8-1-3-删除一个vector会同时删除其储存的元素" class="header-anchor">#</a> 8.1.3 删除一个Vector会同时删除其储存的元素</h2> <p>和其他<code>struct</code>一样，vector会在超出作用域时释放，如下代码所示。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token comment">// do stuff with v</span>
    <span class="token punctuation">}</span> <span class="token comment">// &lt;- v goes out of scope and is freed here</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当vector被删除，其包含的内容也同时被删除。这一点看起来很简单，但当你开始引入对vector元素的引用时，情况就会变得复杂起来。让我们接下来解决这个问题!</p> <h2 id="_8-1-4-从vector读取值"><a href="#_8-1-4-从vector读取值" class="header-anchor">#</a> 8.1.4 从Vector读取值</h2> <p>有两种方法可以引用vector中存储的值：使用索引或者<code>get</code>函数。在下面的示例中，为了更加清晰，我们注释了从这些函数返回的值的类型。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> third<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The third element is {}&quot;</span><span class="token punctuation">,</span> third<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">match</span> v<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Some</span><span class="token punctuation">(</span>third<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The third element is {}&quot;</span><span class="token punctuation">,</span> third<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;There is no third element.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>注意这里的两个细节。首先，我们使用索引值<code>2</code>来获取第三个元素，因为vector的索引是从0开始的。其次，我们使用<code>&amp;</code>和<code>[]</code>，得到一个引用，或者使用<code>get</code>方法并将索引<code>2</code>作为参数，得到一个<code>Option&lt;&amp;T&gt;</code>。
Rust提供这两种引用元素的方法的原因是，当您试图使用现有元素范围之外的索引值时，您可以选择程序的行为方式。作为一个例子，让我们看看当我们有一个包含五个元素的向量，然后尝试使用每种技术访问索引为100的元素时会发生什么，如下所示。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> does_not_exist <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> does_not_exist <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当我们运行这段代码时，第一个[]方法将导致程序混乱，因为它引用了一个不存在的元素。当您希望程序在试图访问超出vector末尾的元素时崩溃时，最好使用此方法。
当<code>get</code>方法被传递到向量外部的索引时，它返回<code>None</code>而不会中断。如果在正常情况下偶尔会访问超出vector范围的元素，则可以使用此方法。然后你的代码将有逻辑来处理<code>Some(&amp;element)</code>或<code>None</code>，如第6章所述。例如，索引可能来自一个人输入一个数字。如果他们不小心输入了一个太大的数字，而程序得到了一个<code>None</code>值，您可以告诉用户当前向量中有多少项，并给他们另一个输入的机会。</p> <p>当程序有一个有效的引用时，借用检查器执行所有权和借用规则(在第4章中介绍)，以确保这个引用和对vector内容的任何其他引用保持有效。回想一下，不能在同一个作用域中有可变和不可变引用的规则。该规则在以下代码中也适用，其中保存一个指向vector中第一个元素的不可变引用，并试图在末尾添加一个元素。如果我们稍后在函数中也试图引用该元素，则此程序将无法工作:</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>    <span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The first element is: {}&quot;</span><span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>编译此代码将遇到以下错误:</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">cargo</span> run
   Compiling collections v0.1.0 <span class="token punctuation">(</span>file:///projects/collections<span class="token punctuation">)</span>
error<span class="token punctuation">[</span>E0502<span class="token punctuation">]</span>: cannot borrow <span class="token variable"><span class="token variable">`</span><span class="token function">v</span><span class="token variable">`</span></span> as mutable because it is also borrowed as immutable
 --<span class="token operator">&gt;</span> src/main.rs:6:5
  <span class="token operator">|</span>
<span class="token number">4</span> <span class="token operator">|</span>     <span class="token builtin class-name">let</span> first <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token operator">|</span>                  - immutable borrow occurs here
<span class="token number">5</span> <span class="token operator">|</span> 
<span class="token number">6</span> <span class="token operator">|</span>     v.push<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">|</span>     ^^^^^^^^^ mutable borrow occurs here
<span class="token number">7</span> <span class="token operator">|</span> 
<span class="token number">8</span> <span class="token operator">|</span>     println<span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">&quot;The first element is: {}&quot;</span>, first<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">|</span>                                          ----- immutable borrow later used here

For <span class="token function">more</span> information about this error, try <span class="token variable"><span class="token variable">`</span>rustc <span class="token parameter variable">--explain</span> E0502<span class="token variable">`</span></span><span class="token builtin class-name">.</span>
error: could not compile <span class="token variable"><span class="token variable">`</span>collections<span class="token variable">`</span></span> due to previous error
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>以上代码看起来应该可以工作:为什么对第一个元素的引用要关心向量末尾的更改?这个错误是由于vector的工作方式:因为vector将值放在内存中相邻的位置，如果没有足够的空间将所有的元素放在vector当前存储的位置上，那么在vector的末尾添加一个新元素可能需要分配新的内存并将旧的元素复制到新空间中。在这种情况下，对第一个元素的引用将指向已释放的内存。借用规则防止程序陷入这种情况。</p> <h2 id="_8-1-5-迭代vector中的值"><a href="#_8-1-5-迭代vector中的值" class="header-anchor">#</a> 8.1.5 迭代Vector中的值</h2> <p>为了依次访问vector中的每个元素，我们将遍历所有元素，而不是使用索引一次访问一个元素。以下代码显示了如何使用for循环获取对i32值的vector中每个元素的不可变引用并打印它们。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token operator">&amp;</span>v <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们还可以遍历可变向量中的每个元素的可变引用，以便对所有元素进行更改。以下代码中的for循环将为每个元素添加50。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>    <span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> v <span class="token punctuation">{</span>
        <span class="token operator">*</span>i <span class="token operator">+=</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>要更改可变引用所引用的值，我们必须使用*解引用操作符来获得i中的值，然后才能使用+=操作符。我们将在第15章的“使用解引用操作符跟随指向值的指针”一节中详细讨论解引用操作符。</p> <h2 id="_8-1-6-利用枚举存储多个类型的值"><a href="#_8-1-6-利用枚举存储多个类型的值" class="header-anchor">#</a> 8.1.6 利用枚举存储多个类型的值</h2> <p>向量只能存储相同类型的值。这可能很不方便;肯定有需要存储不同类型的对象列表的用例。幸运的是，枚举的变体是在相同的枚举类型下定义的，所以当我们需要一种类型来表示不同类型的元素时，我们可以定义和使用枚举!
例如，假设我们想从电子表格中的某一行获取值，其中该行中的某些列包含整数、一些浮点数和一些字符串。我们可以定义一个枚举，其变量将包含不同的值类型，所有枚举变量将被视为相同的类型:枚举的类型。然后我们可以创建一个vector来保存那个enum，最终保存不同的类型。我们在以下代码中演示了这一点。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>    <span class="token keyword">enum</span> <span class="token type-definition class-name">SpreadsheetCell</span> <span class="token punctuation">{</span>
        <span class="token class-name">Int</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Float</span><span class="token punctuation">(</span><span class="token keyword">f64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> row <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span>
        <span class="token class-name">SpreadsheetCell</span><span class="token punctuation">::</span><span class="token class-name">Int</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">SpreadsheetCell</span><span class="token punctuation">::</span><span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  
        <span class="token class-name">SpreadsheetCell</span><span class="token punctuation">::</span><span class="token class-name">Float</span><span class="token punctuation">(</span><span class="token number">10.12</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Rust需要知道在编译时vector中有哪些类型，这样它才能确切地知道需要多少内存来存储每个元素。我们还必须明确该Vector中允许的类型。如果Rust允许一个vector保存任何类型，那么在对vector的元素执行操作时，可能会有一个或多个类型导致错误。使用枚举加上匹配表达式意味着Rust将确保在编译时处理所有可能的情况，如第6章所述。</p> <p>如果您不知道程序在运行时将获得并存储在vector中的详尽类型集，则枚举技术将不起作用。此时，你可以使用<code>trait</code>对象，我们将在第17章中介绍。</p> <p>我们讨论了Vector的一些最常用的方法，你可以（请务必）查看<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html" target="_blank" rel="noopener noreferrer">API文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，以了解标准库在<code>Vec&lt;T&gt;</code>上定义的所有有用方法。例如，除了<code>push</code>之外，<code>pop</code>方法还删除并返回最后一个元素。</p> <p>让我们转到下一个集合类型:<code>String</code>!</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/rust/6_enums_and_pattern_matching/6.3_concise_control_flow_with_if_let.html" class="prev">
        6.3 简明控制流if let
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.9f0d3d57.js" defer></script><script src="/blog/assets/js/2.31e7eaac.js" defer></script><script src="/blog/assets/js/21.ae45e28a.js" defer></script>
  </body>
</html>
