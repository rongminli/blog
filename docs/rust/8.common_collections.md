
# 第八章 常用集合
rust标准库中包含一些非常有用的集合数据类型。大多数其他的数据类型表示一个特定的值，但是集合可以包含多个值。与内建的array和tuple类型不同，集合类型的数据储存在堆中，这意味着集合里面的数据量可以在运行时增加或者减少。不同的集合类型拥有不同的功能和性能。在本章中，我们将讨论三个十分常用的集合类型。
- vector 以连续的方式存储多个值
- string 是字符的集合。之前我们见过这个类型，本章我们将进一步讨论它。
- 用hash map你可以在一个值和另一个值之间建立联系。它是另一个更通用的数据类型map的一个特殊实现。

本章我们将讨论如何创建和更新vector、string和hash map，以及它们的特殊之处。

你可以查看[官方文档](https://doc.rust-lang.org/std/collections/index.html)来学习标准库中提供的其他集合类型。

# 本章目录
[[toc]]

## 8.1 使用Vector来存储列表
第一个我们要讨论的集合类型是 `Vec<T>`，我们叫它vector。Vector可以在内存中以相邻的方式存储多个值，所有的值必须是同一种数据类型。

### 8.1.1 创建Vector
使用 `Vec::new` 方法可以创建一个Vector，如下所示。
``` rust
let v: Vec<i32> = Vec::new();
```
注意，我们在这里添加了一个类型注解。因为没出往Vector中插入任何值，rust无法知晓我们想存储的元素的类型。Vector的实现中使用了泛型，我们将在第十章进一步讨论泛型。现在，我们知道标准库中提供的 `Vec<t>` 可以存储任何类型，你可以在尖括号中指定你想要存储的类型，在上面的代码中我们告诉rust我们想要存储的类型是i32。
通常，我们使用一些值来初始化`Vec<T>`，Rust根据这些值的类型来推断你想存储何种类型的元素，因此你通常不需要使用类型注解。Rust提供了一个宏--vec!来根据给定的值来创建新的Vector。以下代码创建了一个持有1，2和3的`Vec<i32>`，因为整形的默认类型是`i32`，正如我们在第三章中讨论的那样。
``` rust
let v = vec![1,2,3]
```
因为我们使用`i32`类型的值作为初始化的值，于是Rust推断v的类型是`Vec<i32>`，所以我们不再需要类型注解。下一步，我们看看如何更改一个vector。

### 8.1.2 更新Vector
我们可以使用`push`方法往vector添加新的值，如下所示。
``` rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```
同其他变量一样，如果我们想要改变它的值，我们需要使用`mut`关键字使它变成可变对象，正如第三章中讨论的那样。我们插入的值都是`i32`类型，Rust可以中做出推断，因此我们不需要`Vec<i32>`注解。

### 8.1.3 删除一个Vector会同时删除其储存的元素
和其他`struct`一样，vector会在超出作用域时释放，如下代码所示。
``` rust
    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // <- v goes out of scope and is freed here
```
当vector被删除，其包含的内容也同时被删除。这一点看起来很简单，但当你开始引入对vector元素的引用时，情况就会变得复杂起来。让我们接下来解决这个问题!

### 8.1.4 从Vector读取值
有两种方法可以引用vector中存储的值：使用索引或者`get`函数。在下面的示例中，为了更加清晰，我们注释了从这些函数返回的值的类型。
``` rust
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {}", third);

    match v.get(2) {
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }
```
注意这里的两个细节。首先，我们使用索引值`2`来获取第三个元素，因为vector的索引是从0开始的。其次，我们使用`&`和`[]`，得到一个引用，或者使用`get`方法并将索引`2`作为参数，得到一个`Option<&T>`。
Rust提供这两种引用元素的方法的原因是，当您试图使用现有元素范围之外的索引值时，您可以选择程序的行为方式。作为一个例子，让我们看看当我们有一个包含五个元素的向量，然后尝试使用每种技术访问索引为100的元素时会发生什么，如下所示。
``` rust
    let v = vec![1, 2, 3, 4, 5];
    let does_not_exist = &v[100];
    let does_not_exist = v.get(100);
```
当我们运行这段代码时，第一个[]方法将导致程序混乱，因为它引用了一个不存在的元素。当您希望程序在试图访问超出vector末尾的元素时崩溃时，最好使用此方法。
当`get`方法被传递到向量外部的索引时，它返回`None`而不会中断。如果在正常情况下偶尔会访问超出vector范围的元素，则可以使用此方法。然后你的代码将有逻辑来处理`Some(&element)`或`None`，如第6章所述。例如，索引可能来自一个人输入一个数字。如果他们不小心输入了一个太大的数字，而程序得到了一个`None`值，您可以告诉用户当前向量中有多少项，并给他们另一个输入的机会。

当程序有一个有效的引用时，借用检查器执行所有权和借用规则(在第4章中介绍)，以确保这个引用和对vector内容的任何其他引用保持有效。回想一下，不能在同一个作用域中有可变和不可变引用的规则。该规则在以下代码中也适用，其中保存一个指向vector中第一个元素的不可变引用，并试图在末尾添加一个元素。如果我们稍后在函数中也试图引用该元素，则此程序将无法工作:
``` rust
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];

    v.push(6);

    println!("The first element is: {}", first);
```
编译此代码将遇到以下错误:
``` shell
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!("The first element is: {}", first);
  |                                          ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
```

以上代码看起来应该可以工作:为什么对第一个元素的引用要关心向量末尾的更改?这个错误是由于vector的工作方式:因为vector将值放在内存中相邻的位置，如果没有足够的空间将所有的元素放在vector当前存储的位置上，那么在vector的末尾添加一个新元素可能需要分配新的内存并将旧的元素复制到新空间中。在这种情况下，对第一个元素的引用将指向已释放的内存。借用规则防止程序陷入这种情况。

### 8.1.5 迭代Vector中的值
为了依次访问vector中的每个元素，我们将遍历所有元素，而不是使用索引一次访问一个元素。以下代码显示了如何使用for循环获取对i32值的vector中每个元素的不可变引用并打印它们。
``` rust
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{}", i);
    }
```
我们还可以遍历可变向量中的每个元素的可变引用，以便对所有元素进行更改。以下代码中的for循环将为每个元素添加50。
``` rust
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }
```
要更改可变引用所引用的值，我们必须使用*解引用操作符来获得i中的值，然后才能使用+=操作符。我们将在第15章的“使用解引用操作符跟随指向值的指针”一节中详细讨论解引用操作符。

### 8.1.6 使用枚举存储多个类型
向量只能存储相同类型的值。这可能很不方便;肯定有需要存储不同类型的对象列表的用例。幸运的是，枚举的变体是在相同的枚举类型下定义的，所以当我们需要一种类型来表示不同类型的元素时，我们可以定义和使用枚举!
例如，假设我们想从电子表格中的某一行获取值，其中该行中的某些列包含整数、一些浮点数和一些字符串。我们可以定义一个枚举，其变量将包含不同的值类型，所有枚举变量将被视为相同的类型:枚举的类型。然后我们可以创建一个vector来保存那个enum，最终保存不同的类型。我们在以下代码中演示了这一点。
``` rust
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),  
        SpreadsheetCell::Float(10.12),
    ];
```
Rust需要知道在编译时vector中有哪些类型，这样它才能确切地知道需要多少内存来存储每个元素。我们还必须明确该Vector中允许的类型。如果Rust允许一个vector保存任何类型，那么在对vector的元素执行操作时，可能会有一个或多个类型导致错误。使用枚举加上匹配表达式意味着Rust将确保在编译时处理所有可能的情况，如第6章所述。

如果您不知道程序在运行时将获得并存储在vector中的详尽类型集，则枚举技术将不起作用。此时，你可以使用`trait`对象，我们将在第17章中介绍。

我们讨论了Vector的一些最常用的方法，你可以（请务必）查看[API文档](https://doc.rust-lang.org/std/vec/struct.Vec.html)，以了解标准库在`Vec<T>`上定义的所有有用方法。例如，除了`push`之外，`pop`方法还删除并返回最后一个元素。

让我们转到下一个集合类型:`String`!