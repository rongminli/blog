## 匹配控制流结构是什么

Rust有一个非常强大的控制流结构，称为match，它允许您将值与一系列模式进行比较，然后根据匹配的模式执行代码。模式可以由文字值、变量名、通配符和许多其他东西组成;第18章涵盖了所有不同类型的模式及其作用。匹配的力量来自于模式的表达性，以及编译器确认所有可能的情况都得到了处理。

把匹配表达式想象成一个硬币分拣机:硬币沿着带有不同大小孔的轨道滑下，每枚硬币从它遇到的第一个适合它的孔中掉下来。以同样的方式，值在匹配中的每个模式中进行遍历，在值“适合”的第一个模式中，值落入执行期间使用的关联代码块中。

说到硬币，让我们以它们为例来使用match!我们可以编写一个函数，它接受一枚未知的美国硬币，以与计数机类似的方式确定这是哪枚硬币，并以美分为单位返回它的值，如清单6-3所示。

``` rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

清单6-3:一个枚举和一个匹配表达式，它使用枚举的变体作为其模式

让我们在value_in_cents函数中分解匹配。首先，我们列出match关键字，后面跟着一个表达式，在本例中是value coin。这看起来非常类似与if一起使用的表达式，但有一个很大的区别:如果使用if，表达式需要返回一个布尔值，但在这里，它可以返回任何类型。本例中的coin类型是我们在第一行上定义的coin enum。

接下来是 `match` 的分支。一个分支有两个部分:一个模式和一些代码。这里的第一个分支有一个模式，即值Coin::Penny，然后是=>操作符，它将模式和要运行的代码分开。本例中的代码只是值1。每条分支都用逗号隔开。

当匹配表达式执行时，它会按顺序将结果值与每个分支的模式进行比较。如果模式与值匹配，则执行与该模式关联的代码。如果该模式与值不匹配，将继续执行到下一个分支，就像硬币分拣机一样。我们可以有我们需要的任意多的分支:在清单6-3中，我们的有四个分支。

与每个分支相关联的代码是一个表达式，匹配分支中表达式的结果值是整个匹配表达式的返回值。

如果匹配分支代码很短，我们通常不使用花括号，如清单6-3所示，其中每个分支只返回一个值。如果希望在匹配臂中运行多行代码，则必须使用花括号，然后分支后的逗号是可选的。例如，下面的代码打印“Lucky penny!”每次用Coin::Penny调用该方法时，仍然返回块的最后一个值1:

``` rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

## 绑定到值的模式

匹配臂的另一个有用的特性是，它们可以绑定到与模式匹配的值的部分。这就是我们如何从枚举变量中提取值的方法。

作为示例，让我们更改一个枚举变量，以在其中保存数据。从1999年到2008年，美国为50个州的每一面铸造了不同的设计。没有其他硬币有国家图案，所以只有25美分的硬币有这种额外的值。我们可以通过更改Quarter变量来将存储在其中的UsState值添加到枚举中，如清单6-4所示。

``` rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

清单6-4:一个Coin enum，其中Quarter变量也包含一个UsState值

让我们想象一下，一个朋友正试图收集所有50个州的25美分硬币。虽然我们会根据硬币类型对零钱进行分类，但我们也会列出与每个硬币相关的州名，所以如果我们的朋友没有硬币，他们便可以将其添加到自己的收藏中。

在这段代码的匹配表达式中，我们将一个名为state的变量添加到匹配变体Coin::Quarter的值的模式中。当Coin::Quarter匹配时，状态变量将绑定到该Quarter的状态值。然后我们可以在这个手臂的代码中使用state，像这样:

``` rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

如果我们调用value_in_cents(Coin::Quarter(UsState::Alaska))， Coin将是Coin::Quarter(UsState::Alaska)。当我们将该值与每个匹配臂进行比较时，它们都不匹配，直到达到Coin::Quarter(状态)。此时，state的绑定值为UsState::Alaska。然后，我们可以在println!表达式，从而从Quarter的Coin enum变量中获得内部状态值。

## 使用`Option<T>`进行匹配

在上一节中，我们使用`Option<T>`;我们也可以使用match来处理`Option<T>`，就像我们处理Coin enum一样!我们不比较硬币，而是比较`Option<T>`的变体，但匹配表达式的工作方式保持不变。

假设我们想写一个函数，它接受`Option<i32>`，如果里面有一个值，就给这个值加上1。如果内部没有值，函数应该返回None值，并且不尝试执行任何操作。

多亏了match，这个函数非常容易编写，如清单6-5所示。

``` rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

清单6-5:在`Option<i32>`上使用匹配表达式的函数

让我们更详细地研究一下plus_one的第一次执行。当调用plus_one(5)时，plus_one函数体中的变量x将具有Some(5)的值。然后我们将其与每个匹配的手臂进行比较。

``` rust
None => None,
```

Some(5)值与模式None不匹配，因此我们继续进行下一个分支。

``` rust
 Some(i) => Some(i + 1),
```

Some(5)匹配Some(i)吗?为什么会这样呢?我们有相同的变体。i绑定到Some中包含的值，因此i取值5。然后执行匹配臂中的代码，因此我们将i的值加1，并创建一个包含总数为6的新Some值

现在让我们考虑一下清单6-5中plus_one的第二个调用，其中x为None。我们进入比赛，并与第一个手臂进行比较。

``` rust
None => None,
```

它匹配!没有要添加的值，因此程序停止并返回`=>`右侧的None值。因为第一个臂匹配，所以没有其他臂进行比较。

将match和枚举组合在许多情况下都很有用。您将在Rust代码中经常看到这种模式:匹配枚举，将变量绑定到其中的数据，然后基于它执行代码。刚开始这有点棘手，但一旦你习惯了，你就会希望所有语言都能使用它。它一直是用户的最爱。

## 匹配的穷竭性

我们还需要讨论匹配的另一个方面:手臂的模式必须涵盖所有可能性。考虑一下这个版本的plus_one函数，它有一个bug，无法编译:

``` rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

我们没有处理None情况，因此这段代码将导致一个错误。幸运的是，拉斯特知道如何捕捉这种虫子。如果我们试图编译这段代码，我们会得到这样的错误:

``` rust
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --> src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option<i32>` defined here
    = note: the matched value is of type `Option<i32>`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
    |
4   ~             Some(i) => Some(i + 1),
5   ~             None => todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
```

拉斯特知道我们没有涵盖所有可能的情况甚至知道我们忘记了哪个模式!Rust中的匹配是穷尽的:为了使代码有效，我们必须穷尽每一种可能性。特别是在`Option<T>`的情况下，当Rust防止我们忘记显式处理None情况时，它保护我们不假设我们有一个可能为null的值，从而使前面讨论的十亿美元的错误不可能发生。

## Catch-all模式和_占位符

使用枚举，我们还可以对一些特定值采取特殊操作，但对所有其他值采取一个默认操作。想象一下，我们正在执行一款游戏，如果你在掷骰子时掷出3，你的玩家不会移动，而是会得到一顶漂亮的新帽子。如果你掷出7，你的玩家将失去一顶漂亮的帽子。对于所有其他数值，你的玩家将在游戏面板上移动相同数量的空间。下面是一个实现该逻辑的匹配，骰子滚动的结果是硬编码的，而不是一个随机值，所有其他逻辑都是用没有主体的函数表示的，因为实际实现它们超出了本例的范围:

``` rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
```

对于前两个臂，模式是文字值3和7。对于覆盖所有其他可能值的最后一个臂，模式是我们选择命名为other的变量。为另一个手臂运行的代码通过将该变量传递给move_player函数来使用它。

尽管我们没有列出u8可能具有的所有值，但这段代码仍然可以编译，因为最后一个模式将匹配没有特别列出的所有值。这种万能模式满足了匹配必须是详尽无遗的要求。注意，我们必须把“全抓”放在最后，因为模式是按顺序计算的。如果我们把全采臂放得更早，其他臂就永远跑不动了，所以如果我们在全采臂之后加臂，Rust就会警告我们!

Rust还有一个模式，当我们想要一个全面的模式，但不想使用全面模式中的值时，我们可以使用:_是一个特殊的模式，它匹配任何值，但不绑定到该值。这告诉Rust我们不打算使用该值，因此Rust不会警告我们有未使用的变量。

让我们改变游戏规则:现在，如果你摇出的点数不是3或7，你必须再摇一次。我们不再需要使用catch-all值，所以我们可以将代码改为使用_而不是名为other的变量:

``` rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
```

这个例子也满足了穷竭性的要求，因为我们显式地忽略了最后一个分支中的所有其他值;我们没有忘记任何东西。

最后，我们将再一次改变游戏规则，所以如果你摇出3或7以外的点数，那么在你的回合中不会发生其他事情。我们可以通过使用单位值(我们在“元组类型”一节中提到的空元组类型)作为_ arm的代码来表示:

``` rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
```

在这里，我们显式地告诉Rust，我们将不会使用任何与早期手臂中的模式不匹配的其他值，在这种情况下，我们不希望运行任何代码。

我们将在第18章中介绍更多关于模式和匹配的内容。现在，我们将转到if let语法，它的匹配表达式有点冗长的情况下非常有用。