# 简明控制流`if let`

if let语法允许您将if和let组合成一种不那么详细的方式来处理匹配一个模式的值，而忽略其余的值。考虑清单6-6中的程序，它匹配config_max变量中的`Option<u8>`值，但只希望在该值为Some变量时执行代码。

``` rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
```
清单6-6:当值为Some时，只关心执行代码的匹配

如果值是Some，则通过将该值绑定到模式中的变量max，打印出Some变量中的值。我们不想对None值做任何事情。为了满足匹配表达式，我们必须在处理一个变量后添加_ =>()，这是添加的恼人的样板代码。

相反，我们可以用if let用一种更简短的方式来写它。以下代码的行为与清单6-6中的匹配相同:

``` rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
```

语法if let接受一个由等号分隔的模式和表达式。它的工作原理与匹配相同，其中表达式被赋予匹配，而模式是它的第一个臂。在本例中，模式是Some(max)，而max绑定到Some中的值。然后，我们可以在if let块的主体中使用max，方法与在相应的匹配臂中使用max相同。如果值与模式不匹配，则if let块中的代码将不会运行。

使用if let意味着更少的输入、更少的缩进和更少的样板代码。但是，您失去了匹配强制执行的彻底检查。在匹配和if let之间的选择取决于您在特定情况下所做的事情，以及获得简洁性是否为失去详尽的检查所作的适当交换。

换句话说，您可以将if let看作匹配的语法糖，当值匹配一个模式时运行代码，然后忽略所有其他值。

我们可以用if let来包含else语句。与else匹配的代码块与匹配表达式中等价于if let和else的_ case匹配的代码块相同。回想一下清单6-4中的Coin枚举定义，其中Quarter变量也包含一个UsState值。如果我们想要计数我们看到的所有非四分硬币，同时宣布四分硬币的状态，我们可以使用如下匹配表达式来实现:

``` rust
    let mut count = 0;
    match coin {
        Coin::Quarter(state) => println!("State quarter from {:?}!", state),
        _ => count += 1,
    }
```

或者我们可以像这样使用if let和else表达式:

``` rust
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("State quarter from {:?}!", state);
    } else {
        count += 1;
    }
```

如果遇到这样的情况，即程序的逻辑太过冗长，无法使用匹配来表达，请记住，if let也在Rust工具箱中。

## 总结

我们现在已经介绍了如何使用枚举创建自定义类型，这些类型可以是一组枚举值中的一个。我们已经展示了标准库的`Option<T>`类型如何帮助您使用类型系统防止错误。当枚举值中包含数据时，您可以使用match或if let来提取和使用这些值，这取决于您需要处理多少情况。

Rust程序现在可以使用结构和枚举来表达域中的概念。创建在API中使用的自定义类型可以确保类型安全:编译器将确保函数只获得每个函数期望的类型的值。

为了向用户提供一个组织良好的API，它使用简单，只暴露用户需要的内容，现在让我们转向Rust的模块。