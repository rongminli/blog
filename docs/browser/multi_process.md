# Chromium的多进程架构

本篇讲解chromium的高级架构，以及其如何区分不同的进程类型。

## 问题

构建绝不会宕机和绝对安全的渲染引擎事几乎不可能的。

从某方面说，2006年前后的浏览器像是过去单用户，多进程任务协作的操作系统。一个行为不端的应用会使这样的操作系统崩溃，同样一个不正常的网页也会使这样的浏览器崩溃。只要一个渲染引擎或者插件出bug就会干掉整个浏览器和正在运行的标签页。

现代操作系统则更加健壮，因为它们把不同的应用放在彼此隔离的进程中。一个应用崩溃不会损害刀其他的应用或者操作系统的完整性，而且每个用户能访问到的其他用户的数据是有限的。Chromium的架构旨在实现这种更加健壮的设计模式。

## 架构概览

Chromium 使用多进程保护所有的应用免受渲染引擎或其它组件中的bug和小故障的影响。它还限制了每个渲染引擎进程对其他进程和系统其他部分的访问。某种程度上，这给浏览器的内存保护和限制自身对操作系统的访问带来了便利。

我们把运行UI和管理渲染器以及其它进程的之进程称为“浏览器进程”或者“浏览器”（“browser process” or “browser”），同样的，处理网页内容的进程称为“渲染进程”或者“渲染器”。渲染器使用开源的布局引擎Blink来解析和布局HTML。

![浏览器进程架构图](./imgs/browser_achi.png)

## 管理渲染进程

每一个渲染进程有一个全局`RenderProcess`对象，用来管理与父浏览器进程的通讯以及维护全局状态。浏览器维护与每一个渲染进程相对应的`RenderProcessHost`对象，用来管理浏览器状态并和对应的渲染器通讯。浏览和渲染器之间的通讯使用Mojo或者Chromium的IPC系统。

## 管理frame和文档

每一个渲染进程有一个或者多个`RenderFrame`对象对应到包含内容文档的frame。相应的`RenderFrameHost`在浏览器进程中管理与文档对应的状态。每个`RenderFrame`都有一个路由ID，用于区分同一个渲染器中的多个文档或frame。这些ID在每一个渲染进程中都是唯一的，但是在多个渲染器之间不唯一，所以定位一个frame需要一个`RenderProcessHost`和一个路由ID。在渲染器中的特定文档与浏览器之间的通讯通过`RenderProcessHost`完成，它知道如何通过Mojo或IPC来发送消息。

## 组件和接口

在渲染器进程中：
- `RenderProcess`在浏览器中和相应的`RenderProcessHost`处理Mojo设置和遗留IPC。每个渲染器进程只有一个`RenderProcess`对象。
- `RenderFrame`对象在浏览器进程(通过Mojo)和Blink层中与相应的`RenderFrameHost`通信。该对象表示一个web文档在一个标签或子frame中的内容。

在浏览器进程中：
- `Browser`对象表示顶级的浏览器窗口。
- `RenderProcessHost`对象表示浏览器端的一个单一的浏览器到渲染器的IPC链接。每个渲染器进程在浏览器进程中有一个`RenderProcessHost`.
- `RenderFrameHost`对象封装了与`RenderFrame`的通信，`RenderWidgetHost`处理浏览器中`RenderWidget`的输入和绘制。

更多细节参阅[网页是如何显示的](page_render.md)

## 共享渲染器进程

通常，每个新的窗口和标签在一个新的进程中开启。浏览器开启新的进程指导它创建一个`RenderFrame`，这个`RenderFrame`可能在页面中创建更多的`iframe`（它们可能在不同的进程中）。

有时在不同窗口中共享渲染进程是必须的。例如，一个网络应用可以使用`window.open`创建别的窗口，如果新的文档来自同一个源，那么新的文档需要和父窗口公用一个渲染进程。如果进程总数太大，Chromium还具有将新标签页分配给现有进程的策略。这些注意事项和策略在[进程模型]()中进行了描述。

## 发现已崩溃或者行为不当的渲染器

到浏览器进程的每个Mojo或IPC连接都监视进程句柄。如果这些句柄已发出信号，则表示渲染程序已经崩溃，受影响的标签和frame将被通知崩溃。Chromium显示一个“悲伤标签”或“悲伤帧”图像，通知用户渲染器已经崩溃。可以通过按下重新加载按钮或开始一个新的导航来重新加载页面。当这种情况发生时，Chromium会注意到没有渲染器进程，并创建一个新的渲染器进程。

## 渲染器沙盒化

鉴于渲染器运行在一个单独的进程中，我们有机会通过沙箱限制它对系统资源的访问。例如，我们可以确保渲染器对网络的唯一访问是通过Chromium的网络服务。同样，我们可以使用主机操作系统的内置权限限制其对文件系统的访问，或者限制其对用户显示和输入的访问。这些限制极大地限制了折衷的呈现程序进程能够完成的任务。

## 内存回收

由于渲染器运行在独立的进程中，通过降低优先级来隐藏标签变得很简单。通常，Windows上最小化的进程的内存会自动放入“可用内存”池中。在内存不足的情况下，Windows会在交换高优先级内存之前将这些内存交换到磁盘，这有助于保持用户可见程序的响应更快。我们可以将同样的原则应用于隐藏选项卡。当呈现进程没有顶级选项卡时，我们可以释放该进程的“工作集”大小，以提示系统在必要时首先将内存交换到磁盘。因为我们发现，当用户在两个选项卡之间切换时，减少工作集大小也会降低选项卡切换性能，所以我们逐渐释放这些内存。这意味着如果用户切换回最近使用的选项卡，该选项卡的内存比最近使用较少的选项卡更有可能被换回。有足够内存运行所有程序的用户不会注意到这一点。

这有助于我们在内存不足的情况下获得更优的内存占用。与很少使用的后台选项卡相关的内存可以完全交换，而前台选项卡的数据可以完全加载到内存中。相比之下，单进程浏览器将所有选项卡的数据随机分布在内存中，不可能将使用和未使用的数据如此干净地分开，这会浪费内存和性能。

## 其他进程类型

Chromium也将许多其他组件分离到单独的过程中，有时以特定于平台的方式进行。例如，它现在有一个单独的GPU进程、网络服务和存储服务。沙盒实用程序进程还可以用于小型或有风险的任务，作为满足安全性的二规则的一种方式。